package init

import (
	"fmt"
	"os"
	"path/filepath"
)

// generateConfig creates the conveyor.yml configuration file
func generateConfig(opts *Options, configDir, configFilePath, certDir string) error {
	// Check if config file already exists
	if !opts.Force && fileExists(configFilePath) {
		return fmt.Errorf("configuration file already exists at %s (use --force to overwrite)", configFilePath)
	}

	// Use custom config file if provided
	if opts.ConfigFile != "" {
		return copyConfigFile(opts.ConfigFile, configFilePath)
	}

	// Generate default configuration
	return generateDefaultConfig(opts, configDir, configFilePath, certDir)
}

// copyConfigFile copies a user-provided config file to the target location
func copyConfigFile(srcPath, destPath string) error {
	if err := copyFile(srcPath, destPath); err != nil {
		return fmt.Errorf("failed to copy config file: %w", err)
	}

	fmt.Printf("ðŸ“‹ Copied configuration file to %s\n", destPath)
	return nil
}

// generateDefaultConfig creates a default conveyor.yml configuration
func generateDefaultConfig(opts *Options, configDir, configPath, certDir string) error {
	config := fmt.Sprintf(`# Conveyor CI Configuration
# Generated by 'conveyor init'

api:
    port: %d
    auth_enabled: %t
    data: %s

nats:
    port: %d

tls:
    ca: %s
    key: %s
    cert: %s
`,
		opts.APIPort,
		opts.AuthEnabled,
		configDir,
		opts.NatsPort,
		filepath.Join(certDir, "ca.pem"),
		filepath.Join(certDir, "server.key"),
		filepath.Join(certDir, "server.crt"),
	)

	file, err := os.OpenFile(configPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return fmt.Errorf("failed to create config file: %w", err)
	}
	defer file.Close()

	if _, err := file.WriteString(config); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	fmt.Printf("âœ” Generated configuration file: %s\n", configPath)
	return nil
}
