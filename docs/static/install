#!/usr/bin/env bash
set -euo pipefail

# Installer for open-ug/conveyor
# Usage: install-conveyor.sh [--root] [--version vX.X.X] [--help]

REPO="open-ug/conveyor"
API_BASE="https://api.github.com/repos/$REPO/releases"
TMPDIR="$(mktemp -d)"
CURL=""
WGET=""
FORCE_ROOT=0
VERSION=""
QUIET=0

# Colors
_color_red()    { printf '\033[1;31m%s\033[0m\n' "$1"; }
_color_green()  { printf '\033[1;32m%s\033[0m\n' "$1"; }
_color_yellow() { printf '\033[1;33m%s\033[0m\n' "$1"; }
_color_blue()   { printf '\033[1;34m%s\033[0m\n' "$1"; }
_info()    { _color_blue "→ $1"; }
_success() { _color_green "✔ $1"; }
_warn()    { _color_yellow "⚠ $1"; }
_error()   { _color_red "✖ $1"; }

usage() {
  cat <<EOF
Conveyor installer

Usage:
  $0 [--root] [--version vX.X.X] [--help]

Options:
  --root          Install to system path (/usr/local/bin). If run as non-root, sudo will be used.
  --version <vX.X.X>  Install specific release tag (must follow vMAJOR.MINOR.PATCH).
  --help          Show this help.

Examples:
  $0
  $0 --version v1.2.3
  $0 --root
EOF
}

# parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    --root) FORCE_ROOT=1; shift;;
    --version|-v)
      shift
      if [[ $# -eq 0 ]]; then
        _error "--version requires an argument"
        exit 2
      fi
      VERSION="$1"
      shift
      ;;
    --help|-h) usage; exit 0;;
    --quiet) QUIET=1; shift;;
    *)
      _error "Unknown argument: $1"
      usage
      exit 2
      ;;
  esac
done

# ensure curl or wget available
if command -v curl >/dev/null 2>&1; then
  CURL="curl"
elif command -v wget >/dev/null 2>&1; then
  WGET="wget"
else
  _error "curl or wget is required. Please install curl or wget and retry."
  exit 1
fi

# Determine install directory
if [[ "$(id -u)" -eq 0 || "$FORCE_ROOT" -eq 1 ]]; then
  INSTALL_DIR="/usr/local/bin"
  USE_SUDO=0
else
  INSTALL_DIR="$HOME/.local/bin"
  USE_SUDO=0
fi

# A function to run commands with sudo if needed
run_as_root() {
  if [[ "$(id -u)" -ne 0 && "$USE_SUDO" -eq 1 ]]; then
    sudo "$@"
  else
    "$@"
  fi
}

# If user wants --root but is not root, require sudo
if [[ "$FORCE_ROOT" -eq 1 && "$(id -u)" -ne 0 ]]; then
  if command -v sudo >/dev/null 2>&1; then
    USE_SUDO=1
    INSTALL_DIR="/usr/local/bin"
  else
    _error "You requested --root but sudo is not available. Run as root or install sudo."
    exit 1
  fi
fi

_info "Installing to: $INSTALL_DIR"

# Validate version if provided
if [[ -n "$VERSION" ]]; then
  if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    _error "Version must follow vX.Y.Z (example: v1.2.3). Got: $VERSION"
    exit 2
  fi
  API_ENDPOINT="tags/$VERSION"
else
  API_ENDPOINT="latest"
fi

# Detect OS and ARCH
OS="$(uname | tr '[:upper:]' '[:lower:]')"
UNAME_ARCH="$(uname -m)"
case "$UNAME_ARCH" in
  x86_64|amd64) ARCH="amd64";;
  aarch64|arm64) ARCH="arm64";;
  armv7l|armv7) ARCH="armv7";;
  i386|i686) ARCH="386";;
  *) ARCH="$UNAME_ARCH";;
esac

_info "Detected OS: $OS, ARCH: $ARCH"

# Fetch release JSON
RELEASE_JSON="$TMPDIR/release.json"
if [[ -n "$CURL" ]]; then
  if ! $CURL -sSL -H "Accept: application/vnd.github.v3+json" "$API_BASE/$API_ENDPOINT" -o "$RELEASE_JSON"; then
    _error "Failed to fetch release information from GitHub."
    rm -rf "$TMPDIR"
    exit 1
  fi
else
  if ! $WGET -qO "$RELEASE_JSON" --header="Accept: application/vnd.github.v3+json" "$API_BASE/$API_ENDPOINT"; then
    _error "Failed to fetch release information from GitHub."
    rm -rf "$TMPDIR"
    exit 1
  fi
fi

# Extract tag_name (release tag)
RELEASE_TAG="$(grep -oP '"tag_name":\s*"\K[^"]+' "$RELEASE_JSON" || true)"
if [[ -z "$RELEASE_TAG" && -n "$VERSION" ]]; then
  # maybe tag not found
  _error "Release $VERSION not found in repository $REPO."
  rm -rf "$TMPDIR"
  exit 1
fi
if [[ -z "$RELEASE_TAG" ]]; then
  # fallback: if latest but empty, try to find tag by other means
  RELEASE_TAG="$VERSION"
fi
_info "Target release: ${RELEASE_TAG:-(unknown)}"

# Parse assets (pair lines: name|url) robustly without jq
# We'll walk JSON and capture "name" and next "browser_download_url"
mapfile -t ASSET_LINES < <(
  awk '
    BEGIN { name = ""; url = ""; }
    {
      # trim leading spaces
      line = $0;
      sub(/^[ \t]*/, "", line);
      if (match(line, /^"name":[ \t]*"/)) {
        # extract between quotes
        gsub(/^"name":[ \t]*"/, "", line);
        gsub(/",$|\",$|",?$/, "", line);
        name = line;
      }
      if (match(line, /^"browser_download_url":[ \t]*"/)) {
        gsub(/^"browser_download_url":[ \t]*"/, "", line);
        gsub(/",$|\",$|",?$/, "", line);
        url = line;
        if (name != "" && url != "") {
          print name "|" url;
          name = ""; url = "";
        }
      }
    }
  ' "$RELEASE_JSON"
)

if [[ ${#ASSET_LINES[@]} -eq 0 ]]; then
  _warn "No release assets found for $RELEASE_TAG. Exiting."
  rm -rf "$TMPDIR"
  exit 1
fi

# Choose best asset:
# 1) name contains RELEASE_TAG, OS and ARCH (case-insensitive)
# 2) name contains RELEASE_TAG and OS
# 3) name contains RELEASE_TAG
# 4) fallback: first asset

chosen_name=""
chosen_url=""
lower_tag="$(echo "$RELEASE_TAG" | tr '[:upper:]' '[:lower:]')"
for line in "${ASSET_LINES[@]}"; do
  name="${line%%|*}"
  url="${line#*|}"
  lname="$(echo "$name" | tr '[:upper:]' '[:lower:]')"
  if [[ "$lname" == *"$lower_tag"* && "$lname" == *"$OS"* && "$lname" == *"$ARCH"* ]]; then
    chosen_name="$name"
    chosen_url="$url"
    break
  fi
done

if [[ -z "$chosen_url" ]]; then
  for line in "${ASSET_LINES[@]}"; do
    name="${line%%|*}"
    url="${line#*|}"
    lname="$(echo "$name" | tr '[:upper:]' '[:lower:]')"
    if [[ "$lname" == *"$lower_tag"* && "$lname" == *"$OS"* ]]; then
      chosen_name="$name"
      chosen_url="$url"
      break
    fi
  done
fi

if [[ -z "$chosen_url" ]]; then
  for line in "${ASSET_LINES[@]}"; do
    name="${line%%|*}"
    url="${line#*|}"
    lname="$(echo "$name" | tr '[:upper:]' '[:lower:]')"
    if [[ "$lname" == *"$lower_tag"* ]]; then
      chosen_name="$name"
      chosen_url="$url"
      break
    fi
  done
fi

# fallback to first asset
if [[ -z "$chosen_url" ]]; then
  _warn "Could not find an asset that contains the release tag; falling back to first asset."
  line="${ASSET_LINES[0]}"
  chosen_name="${line%%|*}"
  chosen_url="${line#*|}"
fi

_info "Selected asset: $chosen_name"
_info "Download URL: $chosen_url"

# Download asset
asset_path="$TMPDIR/$chosen_name"
_info "Downloading..."
if [[ -n "$CURL" ]]; then
  if ! $CURL -sSL --fail -o "$asset_path" "$chosen_url"; then
    _error "Download failed."
    rm -rf "$TMPDIR"
    exit 1
  fi
else
  if ! $WGET -q -O "$asset_path" "$chosen_url"; then
    _error "Download failed."
    rm -rf "$TMPDIR"
    exit 1
  fi
fi
_success "Downloaded to $asset_path"

# Determine if asset is an archive or a binary
BIN_CANDIDATE=""
file_lower="$(echo "$chosen_name" | tr '[:upper:]' '[:lower:]')"

if [[ "$file_lower" =~ \.tar\.gz$ ]] || [[ "$file_lower" =~ \.tgz$ ]]; then
  _info "Archive detected, extracting..."
  tar -xzf "$asset_path" -C "$TMPDIR"
  # find an executable candidate named 'conveyor' or containing 'conveyor'
  BIN_CANDIDATE="$(find "$TMPDIR" -type f -perm -111 -iname 'conveyor*' -print -quit || true)"
  if [[ -z "$BIN_CANDIDATE" ]]; then
    # fallback: pick first executable
    BIN_CANDIDATE="$(find "$TMPDIR" -type f -perm -111 -print -quit || true)"
  fi
elif [[ "$file_lower" =~ \.zip$ ]]; then
  if command -v unzip >/dev/null 2>&1; then
    _info "Zip archive detected, extracting..."
    unzip -q "$asset_path" -d "$TMPDIR"
    BIN_CANDIDATE="$(find "$TMPDIR" -type f -perm -111 -iname 'conveyor*' -print -quit || true)"
    if [[ -z "$BIN_CANDIDATE" ]]; then
      BIN_CANDIDATE="$(find "$TMPDIR" -type f -perm -111 -print -quit || true)"
    fi
  else
    _warn "Asset is zip but unzip is not installed. Treating downloaded file as binary."
    BIN_CANDIDATE="$asset_path"
  fi
else
  # assume binary; if it's not executable, we'll make it so
  BIN_CANDIDATE="$asset_path"
fi

if [[ -z "$BIN_CANDIDATE" ]]; then
  _error "Could not find an executable binary inside the asset."
  rm -rf "$TMPDIR"
  exit 1
fi

_info "Using binary: $BIN_CANDIDATE"

# Ensure executable
chmod +x "$BIN_CANDIDATE" || true

# Move to target path with name 'conveyor'
DEST_PATH="$INSTALL_DIR/conveyor"

if [[ -e "$DEST_PATH" ]]; then
  _warn "Existing conveyor found at $DEST_PATH. It will be overwritten."
fi

_info "Installing to $DEST_PATH ..."
if [[ "$(id -u)" -ne 0 && "$USE_SUDO" -eq 1 ]]; then
  # use sudo to move
  sudo mkdir -p "$INSTALL_DIR"
  sudo mv -f "$BIN_CANDIDATE" "$DEST_PATH"
  sudo chmod +x "$DEST_PATH"
else
  mkdir -p "$INSTALL_DIR"
  mv -f "$BIN_CANDIDATE" "$DEST_PATH"
  chmod +x "$DEST_PATH"
fi

_success "Installed conveyor to $DEST_PATH"

# Check if install dir is in PATH
if ! echo "$PATH" | tr ':' '\n' | grep -qx "$INSTALL_DIR"; then
  _warn "$INSTALL_DIR is not in your PATH."
  if [[ "$INSTALL_DIR" == "$HOME/.local/bin" ]]; then
    cat <<EOF

Add the following to your shell profile to use 'conveyor' as a command:

  export PATH=\"\$HOME/.local/bin:\$PATH\"

You can add it to your ~/.profile, ~/.bashrc or ~/.zshrc depending on your shell.
EOF
  else
    _warn "You may need to log out/in or ensure /usr/local/bin is in PATH."
  fi
else
  _success "Installation path is in PATH. You can run 'conveyor' now."
fi

# cleanup
rm -rf "$TMPDIR"

# Print installed version (if binary supports --version)
if command -v conveyor >/dev/null 2>&1; then
  _info "Installed binary reports:"
  conveyor --version 2>/dev/null || _info "(conveyor --version not supported by this binary)"
fi

_success "Done."
